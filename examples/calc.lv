-- Expression Evaluator
-- A mini interpreter inside an interpreter: evaluates arithmetic expression trees
-- Showcases tagged values as AST, recursive pattern matching, error handling, and pipelines

-- Build an expression tree using tagged values
-- Num(n)    — numeric literal
-- Add(a, b) — addition
-- Mul(a, b) — multiplication
-- Neg(a)    — negation
-- Div(a, b) — division (can fail)

-- Evaluate an expression tree, returning Ok(result) or Err(msg)
let rec eval = fn(expr) ->
  match expr {
    Num(n) -> Ok(n),
    Add(a, b) -> (eval(a)? + eval(b)? |> fn(r) -> Ok(r)),
    Mul(a, b) -> (eval(a)? * eval(b)? |> fn(r) -> Ok(r)),
    Neg(a) -> (0 - eval(a)? |> fn(r) -> Ok(r)),
    Div(a, b) -> (
      let bv = eval(b)? in
      match bv == 0 {
        true -> Err("division by zero"),
        false -> Ok(eval(a)? / bv)
      }
    ),
    _ -> Err("unknown expression")
  }
in

-- Pretty-print an expression as a human-readable string
let rec show = fn(expr) ->
  match expr {
    Num(n) -> to_string(n),
    Add(a, b) -> show(a) ++ " + " ++ show(b),
    Mul(a, b) -> "(" ++ show(a) ++ ") * " ++ show(b),
    Neg(a) -> "-(" ++ show(a) ++ ")",
    Div(a, b) -> show(a) ++ " / " ++ show(b),
    _ -> "unknown"
  }
in

-- Format an evaluation result
let format_result = fn(expr) ->
  ((eval(expr)? |> fn(v) -> show(expr) ++ " = " ++ to_string(v)) |> catch e -> show(expr) ++ " = Error: " ++ e)
in

let p1 = print("=== Expression Evaluator ===") in
let p2 = print("") in

-- Simple: 2 + 3
let e1 = Add(Num(2), Num(3)) in
let p3 = print(format_result(e1)) in

-- Nested: (2 + 3) * -(4)
let e2 = Mul(Add(Num(2), Num(3)), Neg(Num(4))) in
let p4 = print(format_result(e2)) in

-- Division by zero
let e3 = Div(Num(10), Num(0)) in
let p5 = print(format_result(e3)) in

-- Successful division
let e4 = Div(Num(10), Num(3)) in
let p6 = print(format_result(e4)) in

-- Unknown expression
let e5 = "not an expression" in
let p7 = print(format_result(e5)) in

print("=== Done! ===")
